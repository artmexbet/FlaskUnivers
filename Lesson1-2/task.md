# Сегодняшнее задание
## Продолжение предыдущего занятия
Написать веб-приложение для пиццерии. Добавьте вашему решению
словарь с заказами следующего вида
```python
orders = {
    "Заказ от 12:30": {
        "items": ["Пицца пепперони", "Пицца гавайская 32 см"], 
        "address": "г. Красноярск, ул. Корнеева 50",
        "comment": "Оставьте заказ у охранника"
    }
}
```
Это словарь заказов, которые сделаны в пиццерию. На старте он может быть пустым.
Вы должны реализовать возможность добавлять и удалять заказы.

**Отмечу, что идентификатором не обязательно должна являться дата, это может быть и число**


*Добавить возможность:*
* Создавать новые заказы
* Получать список имеющихся заказов
* Получать инфу о заказе по конкретному идентификатору
* Удалять заказ (отмечать заказ выполненным. 
Он должен удалиться из общего списка)
* Редактировать заказ по ID
## Базы данных
### Теоретическая часть
Базы данных - по сути своей, делятся на 2 вида: реляционные и нереляционные (всё просто).
Реляционные представляют собой какого-то вида таблицы с заданным количеством столбцов.
Таблицы могут иметь связи между собой. Поясню:

**Таблица заказов**

| ID заказа | Address                        | comment                    |
|-----------|--------------------------------|----------------------------|
| 1         | г. Красноярск, ул. Корнеева 50 | Оставьте заказ у охранника |

**Таблица товаров**

| ID товара | Название  | Цена |
|-----------|-----------|------|
| 1         | Пепперони | 350  |
| 2         | Гавайская | 500  |

**Таблица связи**

| ID связи | ID заказа | ID товара |
|----------|-----------|-----------|
| 1        | 1         | 1         |
| 2        | 1         | 2         |

ID связи - обязательная строка, так как каждый отдельный объект *(объектом здесь будем называть
строки)* должен отличаться от других, и именно идентификатор будет за это различие отвечать. 
Столбцы, отличающие строки друг от друга *(и позволяющие, кстати, получать элементы)* называют
*первичными ключами*.

Несмотря на то, что таблица связи у нас всего одна, связей здесь несколько больше.
В таблице связей мы обращаемся к таблицам заказов и товаров при помощи идентификаторов. 
При помощи их же сможем получить информацию о заказе или товаре, зная о связи. Или,
к примеру, получить все товары, привязанные к одному из заказов.

#### Типы связей
Существует несколько типов связей:
* один к одному
* многие к одному
* один ко многим (от предыдущего отличается, по сути, направлением)
* многие ко многим (это сложная связь)

### Практика
Существует несколько разных баз данных. Они отличаются друг от друга многими параметрами. 
В мире сейчас очень активно используют PostgreSQL. Однако мы начнём наш путь не с него,
а с более простой БД. С sqlite. Она удобна и одновременно уязвима тем, что в ней все данные хранятся в одном файле,
и запросы, соответственно, тоже идут к одному файлу.

Для того чтобы работать с sqlite в python предусмотрена одноименная библиотека:
```python
from sqlite import connect
```
Из этой библиотеки мы импортируем функцию connect. Она-то и будет подключать нас к файлу.
```python
db = connect("my_database.sqlite")
cur = db.cursor()
```
Вы могли заметить, что помимо подключения к базе данных в примере так же был создан курсор.
Он необходим для обращения к базе.
#### Синтаксис запросов
Всё это время мы говорили о базах данных, но ни разу не упомянули о том, как с ними взаимодействовать.
Для этого был придуман отдельный язык - **SQL**.

Он предоставляет довольно обширный функционал, мы познакомимся с его основами. Потренировать
более обширные навыки вы можете <a href="https://sql-academy.org/ru">тут</a>.

Синтаксис запроса на получение данных выглядит следующим образом:
```sql
SELECT перечень_полей FROM имя_таблицы
WHERE условие
```
